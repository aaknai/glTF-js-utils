(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["GLTFUtils"] = factory();
	else
		root["GLTFUtils"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/asset.ts":
/*!**********************!*\
  !*** ./src/asset.ts ***!
  \**********************/
/*! exports provided: GLTFAsset */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GLTFAsset\", function() { return GLTFAsset; });\nvar GLTFAsset = /** @class */ (function () {\n    function GLTFAsset() {\n        this.copyright = \"\";\n        this.defaultScene = 0;\n        this.generator = \"glTF-js-utils\";\n        this._scenes = [];\n    }\n    GLTFAsset.prototype.setDefaultScene = function (scene) {\n        if (typeof scene === \"number\")\n            this.defaultScene = scene;\n        else {\n            var sceneIndex = this._scenes.indexOf(scene);\n            if (sceneIndex === -1)\n                throw new Error(\"Scene passed to setDefaultScene was not found.\");\n            this.defaultScene = sceneIndex;\n        }\n    };\n    GLTFAsset.prototype.addScene = function (scene) {\n        if (this._scenes.indexOf(scene) >= 0)\n            throw new Error(\"Scene passed to addScene was added prior.\");\n        this._scenes.push(scene);\n    };\n    GLTFAsset.prototype.removeScene = function (scene) {\n        var sceneIndex = this._scenes.indexOf(scene);\n        if (sceneIndex >= 0)\n            this._scenes.splice(sceneIndex, 1);\n    };\n    GLTFAsset.prototype.forEachScene = function (fn) {\n        this._scenes.forEach(fn);\n    };\n    return GLTFAsset;\n}());\n\n\n\n//# sourceURL=webpack://GLTFUtils/./src/asset.ts?");

/***/ }),

/***/ "./src/buffer.ts":
/*!***********************!*\
  !*** ./src/buffer.ts ***!
  \***********************/
/*! exports provided: Buffer, BufferView */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Buffer\", function() { return Buffer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BufferView\", function() { return BufferView; });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"./src/types.ts\");\n\nvar Buffer = /** @class */ (function () {\n    function Buffer() {\n        this._bufferViews = [];\n    }\n    Buffer.prototype.addBufferView = function (componentType, dataType) {\n        var view = new BufferView(this, componentType, dataType);\n        this._bufferViews.push(view);\n        return view;\n    };\n    Buffer.prototype.getByteOffset = function (bufferView) {\n        var byteOffset = 0;\n        for (var _i = 0, _a = this._bufferViews; _i < _a.length; _i++) {\n            var view = _a[_i];\n            if (view === bufferView) {\n                return byteOffset;\n            }\n            byteOffset += view.getSize();\n        }\n        throw \"Given bufferView was not present in this buffer\";\n    };\n    Buffer.prototype.getArrayBuffer = function () {\n        var byteLength = this._getTotalSize();\n        var buffer = new ArrayBuffer(byteLength);\n        var currentIndex = 0;\n        for (var _i = 0, _a = this._bufferViews; _i < _a.length; _i++) {\n            var bufferView = _a[_i];\n            bufferView.write(buffer, currentIndex);\n            currentIndex += bufferView.getSize();\n        }\n        return buffer;\n    };\n    Buffer.prototype._getTotalSize = function () {\n        var byteLength = 0;\n        for (var _i = 0, _a = this._bufferViews; _i < _a.length; _i++) {\n            var bufferView = _a[_i];\n            byteLength += bufferView.getSize();\n        }\n        return byteLength;\n    };\n    return Buffer;\n}());\n\nvar BufferView = /** @class */ (function () {\n    function BufferView(buffer, componentType, dataType) {\n        this._data = [];\n        this._accessorIndex = -1;\n        this._buffer = buffer;\n        this._componentType = componentType;\n        this._dataType = dataType;\n    }\n    BufferView.prototype.push = function (item) {\n        this._data.push(item);\n    };\n    BufferView.prototype.getSize = function () {\n        return this._data.length * this._sizeOfComponentType();\n    };\n    BufferView.prototype.getByteOffset = function () {\n        return this._buffer.getByteOffset(this);\n    };\n    BufferView.prototype.write = function (buffer, startIndex) {\n        var dataView = new DataView(buffer, startIndex);\n        var sizeOfComponentType = this._sizeOfComponentType();\n        for (var i = 0; i < this._data.length; i++) {\n            var val = this._data[i];\n            this._writeValue(dataView, i * sizeOfComponentType, val);\n        }\n    };\n    BufferView.prototype.startAccessor = function () {\n        if (this._accessorIndex >= 0)\n            throw \"Accessor was started without ending the previous one\";\n        this._accessorIndex = this._data.length;\n    };\n    BufferView.prototype.endAccessor = function () {\n        if (this._accessorIndex < 0)\n            throw \"An accessor was not started, but was attempted to be ended\";\n        var elementSize = this._getElementSize();\n        var numComponentsForDataType = this._numComponentsForDataType();\n        var numElements = (this._data.length - this._accessorIndex) / numComponentsForDataType;\n        if (numElements % 1)\n            throw \"An accessor was ended with missing component values\";\n        var info = {\n            byteOffset: elementSize * (this._accessorIndex / numComponentsForDataType),\n            componentType: this._componentType,\n            count: numElements,\n            type: this._dataType,\n        };\n        this._accessorIndex = -1;\n        return info;\n    };\n    BufferView.prototype._getElementSize = function () {\n        return this._sizeOfComponentType() * this._numComponentsForDataType();\n    };\n    BufferView.prototype._sizeOfComponentType = function () {\n        switch (this._componentType) {\n            case _types__WEBPACK_IMPORTED_MODULE_0__[\"ComponentType\"].BYTE:\n            case _types__WEBPACK_IMPORTED_MODULE_0__[\"ComponentType\"].UNSIGNED_BYTE:\n                return 1;\n            case _types__WEBPACK_IMPORTED_MODULE_0__[\"ComponentType\"].SHORT:\n            case _types__WEBPACK_IMPORTED_MODULE_0__[\"ComponentType\"].UNSIGNED_SHORT:\n                return 2;\n            case _types__WEBPACK_IMPORTED_MODULE_0__[\"ComponentType\"].UNSIGNED_INT:\n            case _types__WEBPACK_IMPORTED_MODULE_0__[\"ComponentType\"].FLOAT:\n                return 4;\n        }\n        throw \"Unrecognized component type \" + this._componentType;\n    };\n    BufferView.prototype._numComponentsForDataType = function () {\n        switch (this._dataType) {\n            case _types__WEBPACK_IMPORTED_MODULE_0__[\"DataType\"].SCALAR:\n                return 1;\n            case _types__WEBPACK_IMPORTED_MODULE_0__[\"DataType\"].VEC2:\n                return 2;\n            case _types__WEBPACK_IMPORTED_MODULE_0__[\"DataType\"].VEC3:\n                return 3;\n            case _types__WEBPACK_IMPORTED_MODULE_0__[\"DataType\"].VEC4:\n            case _types__WEBPACK_IMPORTED_MODULE_0__[\"DataType\"].MAT2:\n                return 4;\n            case _types__WEBPACK_IMPORTED_MODULE_0__[\"DataType\"].MAT3:\n                return 9;\n            case _types__WEBPACK_IMPORTED_MODULE_0__[\"DataType\"].MAT4:\n                return 16;\n        }\n        throw \"Unsupported data type\";\n    };\n    BufferView.prototype._writeValue = function (dataView, index, val) {\n        switch (this._componentType) {\n            case _types__WEBPACK_IMPORTED_MODULE_0__[\"ComponentType\"].BYTE:\n                dataView.setInt8(index, val);\n                break;\n            case _types__WEBPACK_IMPORTED_MODULE_0__[\"ComponentType\"].UNSIGNED_BYTE:\n                dataView.setUint8(index, val);\n                break;\n            case _types__WEBPACK_IMPORTED_MODULE_0__[\"ComponentType\"].SHORT:\n                dataView.setInt16(index, val, true);\n                break;\n            case _types__WEBPACK_IMPORTED_MODULE_0__[\"ComponentType\"].UNSIGNED_SHORT:\n                dataView.setUint16(index, val, true);\n                break;\n            case _types__WEBPACK_IMPORTED_MODULE_0__[\"ComponentType\"].UNSIGNED_INT:\n                dataView.setUint32(index, val, true);\n                break;\n            case _types__WEBPACK_IMPORTED_MODULE_0__[\"ComponentType\"].FLOAT:\n                dataView.setFloat32(index, val, true);\n                break;\n            default:\n                throw \"Unsupported data type\";\n        }\n    };\n    return BufferView;\n}());\n\n\n\n//# sourceURL=webpack://GLTFUtils/./src/buffer.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! exports provided: GLTFAsset, Scene, Node, Mesh, Material, Texture, Vertex, XYZPair, Quaternion, glTFAssetFromTHREE, AlphaMode, ComponentType, DataType, MeshMode, RGBColor, RGBAColor, VertexColorMode, WrappingMode, BufferOutputType, ImageOutputType, exportGLTF, exportGLTFZip */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BufferOutputType\", function() { return BufferOutputType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ImageOutputType\", function() { return ImageOutputType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"exportGLTF\", function() { return exportGLTF; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"exportGLTFZip\", function() { return exportGLTFZip; });\n/* harmony import */ var _asset__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./asset */ \"./src/asset.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"GLTFAsset\", function() { return _asset__WEBPACK_IMPORTED_MODULE_0__[\"GLTFAsset\"]; });\n\n/* harmony import */ var _scene__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scene */ \"./src/scene.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Scene\", function() { return _scene__WEBPACK_IMPORTED_MODULE_1__[\"Scene\"]; });\n\n/* harmony import */ var _node__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node */ \"./src/node.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Node\", function() { return _node__WEBPACK_IMPORTED_MODULE_2__[\"Node\"]; });\n\n/* harmony import */ var _mesh__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mesh */ \"./src/mesh.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Mesh\", function() { return _mesh__WEBPACK_IMPORTED_MODULE_3__[\"Mesh\"]; });\n\n/* harmony import */ var _material__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./material */ \"./src/material.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Material\", function() { return _material__WEBPACK_IMPORTED_MODULE_4__[\"Material\"]; });\n\n/* harmony import */ var _texture__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./texture */ \"./src/texture.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Texture\", function() { return _texture__WEBPACK_IMPORTED_MODULE_5__[\"Texture\"]; });\n\n/* harmony import */ var _vertex__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./vertex */ \"./src/vertex.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Vertex\", function() { return _vertex__WEBPACK_IMPORTED_MODULE_6__[\"Vertex\"]; });\n\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./math */ \"./src/math.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"XYZPair\", function() { return _math__WEBPACK_IMPORTED_MODULE_7__[\"XYZPair\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Quaternion\", function() { return _math__WEBPACK_IMPORTED_MODULE_7__[\"Quaternion\"]; });\n\n/* harmony import */ var _threejs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./threejs */ \"./src/threejs.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"glTFAssetFromTHREE\", function() { return _threejs__WEBPACK_IMPORTED_MODULE_8__[\"glTFAssetFromTHREE\"]; });\n\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./types */ \"./src/types.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"AlphaMode\", function() { return _types__WEBPACK_IMPORTED_MODULE_9__[\"AlphaMode\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ComponentType\", function() { return _types__WEBPACK_IMPORTED_MODULE_9__[\"ComponentType\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"DataType\", function() { return _types__WEBPACK_IMPORTED_MODULE_9__[\"DataType\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MeshMode\", function() { return _types__WEBPACK_IMPORTED_MODULE_9__[\"MeshMode\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"RGBColor\", function() { return _types__WEBPACK_IMPORTED_MODULE_9__[\"RGBColor\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"RGBAColor\", function() { return _types__WEBPACK_IMPORTED_MODULE_9__[\"RGBAColor\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"VertexColorMode\", function() { return _types__WEBPACK_IMPORTED_MODULE_9__[\"VertexColorMode\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"WrappingMode\", function() { return _types__WEBPACK_IMPORTED_MODULE_9__[\"WrappingMode\"]; });\n\n/* harmony import */ var _buffer__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./buffer */ \"./src/buffer.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\nvar BufferOutputType;\n(function (BufferOutputType) {\n    /** Create separate files for binary buffers (default) */\n    BufferOutputType[BufferOutputType[\"External\"] = 0] = \"External\";\n    /** Embed buffers as data URIs. */\n    BufferOutputType[BufferOutputType[\"DataURI\"] = 1] = \"DataURI\";\n})(BufferOutputType || (BufferOutputType = {}));\nvar ImageOutputType;\n(function (ImageOutputType) {\n    /** Create separate files for images (default) */\n    ImageOutputType[ImageOutputType[\"External\"] = 0] = \"External\";\n    /** Embed images as data URIs. */\n    ImageOutputType[ImageOutputType[\"DataURI\"] = 1] = \"DataURI\";\n})(ImageOutputType || (ImageOutputType = {}));\nvar MODEL_NAME = \"model.gltf\";\n/**\n * Creates a glTF model from a GLTFAsset structure.\n * @param asset GLTFAsset model structure\n * @param options\n * @returns An object, each key pointing to a file.\n */\nfunction exportGLTF(asset, options) {\n    options = options || {};\n    var gltf = {\n        asset: {\n            version: \"2.0\",\n            copyright: asset.copyright,\n            generator: asset.generator,\n        },\n    };\n    addScenes(gltf, asset);\n    var currentData = 1;\n    var currentImg = 1;\n    var output = {};\n    var jsonSpacing = options.hasOwnProperty(\"jsonSpacing\") ? options.jsonSpacing : 4;\n    var gltfString = JSON.stringify(gltf, function (key, value) {\n        if (value instanceof ArrayBuffer) {\n            if (options.bufferOutputType === BufferOutputType.DataURI) {\n                return encodeBase64DataUri(value);\n            }\n            else { // BufferOutputType.External\n                var filename = \"data\" + currentData + \".bin\";\n                currentData++;\n                output[filename] = value;\n                return filename;\n            }\n        }\n        if (value instanceof HTMLImageElement || value instanceof HTMLCanvasElement) {\n            if (options.imageOutputType === ImageOutputType.DataURI) {\n                return imageToDataURI(value);\n            }\n            else { // ImageOutputType.External\n                var filename = \"img\" + currentImg + \".png\";\n                currentImg++;\n                output[filename] = imageToDataURI(value);\n                // Strip off data uri schema\n                output[filename] = output[filename].substr(output[filename].indexOf(\",\") + 1);\n                return filename;\n            }\n        }\n        return value;\n    }, jsonSpacing);\n    output[MODEL_NAME] = gltfString;\n    return output;\n}\n/**\n * Creates a ZIP file of a glTF model from a GLTFAsset structure.\n * @param asset GLTFAsset model structure\n * @param options\n * @returns A Promise to receive a ZIP blob is returned instead.\n */\nfunction exportGLTFZip(asset, jsZip, options) {\n    var output = exportGLTF(asset, options);\n    var zip = new jsZip();\n    for (var filename in output) {\n        if (filename !== MODEL_NAME && typeof output[filename] === \"string\") { // An image\n            zip.file(filename, output[filename], { base64: true });\n        }\n        else {\n            zip.file(filename, output[filename]);\n        }\n    }\n    return zip.generateAsync({ type: \"blob\" });\n}\nfunction addScenes(gltf, asset) {\n    gltf.scene = asset.defaultScene;\n    asset.forEachScene(function (scene) {\n        addScene(gltf, scene);\n    });\n}\nfunction addScene(gltf, scene) {\n    if (!gltf.scenes)\n        gltf.scenes = [];\n    var gltfScene = {};\n    if (scene.name)\n        gltfScene.name = scene.name;\n    scene.forEachNode(function (node) {\n        if (!gltfScene.nodes)\n            gltfScene.nodes = [];\n        var index = addNode(gltf, node);\n        gltfScene.nodes.push(index);\n    });\n    gltf.scenes.push(gltfScene);\n}\nfunction addNode(gltf, node) {\n    if (!gltf.nodes)\n        gltf.nodes = [];\n    var gltfNode = {};\n    if (node.name)\n        gltfNode.name = node.name;\n    var translation = node.getTranslation();\n    if (translation.x !== 0 || translation.y !== 0 || translation.z !== 0)\n        gltfNode.translation = translation.toArray();\n    var rotation = node.getRotationQuaternion();\n    if (rotation.x !== 0 || rotation.y !== 0 || rotation.z !== 0 || rotation.w !== 1)\n        gltfNode.rotation = rotation.toArray();\n    var scale = node.getScale();\n    if (scale.x !== 1 || scale.y !== 1 || scale.z !== 1)\n        gltfNode.scale = scale.toArray();\n    var addedIndex = gltf.nodes.length;\n    gltf.nodes.push(gltfNode);\n    if (node.mesh) {\n        gltfNode.mesh = addMesh(gltf, node.mesh);\n    }\n    else {\n        node.forEachNode(function (node) {\n            if (!gltfNode.children)\n                gltfNode.children = [];\n            var index = addNode(gltf, node);\n            gltfNode.children.push(index);\n        });\n    }\n    return addedIndex;\n}\nfunction addMesh(gltf, mesh) {\n    if (!gltf.meshes)\n        gltf.meshes = [];\n    if (mesh.mode !== _types__WEBPACK_IMPORTED_MODULE_9__[\"MeshMode\"].TRIANGLES)\n        throw \"MeshMode other than TRIANGLES not currently supported\";\n    addMaterials(gltf, mesh.material);\n    var gltfMesh = {\n        primitives: [],\n    };\n    var addedIndex = gltf.meshes.length;\n    gltf.meshes.push(gltfMesh);\n    var meshBuffer = new _buffer__WEBPACK_IMPORTED_MODULE_10__[\"Buffer\"]();\n    var meshBufferIndex = addBuffer(gltf, meshBuffer);\n    var vertexBufferView = meshBuffer.addBufferView(_types__WEBPACK_IMPORTED_MODULE_9__[\"ComponentType\"].FLOAT, _types__WEBPACK_IMPORTED_MODULE_9__[\"DataType\"].VEC3);\n    var vertexBufferIndex = addBufferView(gltf, vertexBufferView, meshBufferIndex);\n    var vertexNormalBufferView = meshBuffer.addBufferView(_types__WEBPACK_IMPORTED_MODULE_9__[\"ComponentType\"].FLOAT, _types__WEBPACK_IMPORTED_MODULE_9__[\"DataType\"].VEC3);\n    var vertexNormalBufferIndex = addBufferView(gltf, vertexNormalBufferView, meshBufferIndex);\n    var vertexUVBufferView = meshBuffer.addBufferView(_types__WEBPACK_IMPORTED_MODULE_9__[\"ComponentType\"].FLOAT, _types__WEBPACK_IMPORTED_MODULE_9__[\"DataType\"].VEC2);\n    var vertexUVBufferIndex = addBufferView(gltf, vertexUVBufferView, meshBufferIndex);\n    var vertexColorBufferView = meshBuffer.addBufferView(_types__WEBPACK_IMPORTED_MODULE_9__[\"ComponentType\"].UNSIGNED_BYTE, _types__WEBPACK_IMPORTED_MODULE_9__[\"DataType\"].VEC3);\n    var vertexColorBufferIndex = addBufferView(gltf, vertexColorBufferView, meshBufferIndex);\n    var lastMaterial;\n    var lastMaterialIndex = null;\n    mesh.forEachFace(function (v1, v2, v3, color, materialIndex) {\n        var currentMaterial = mesh.material[materialIndex];\n        lastMaterial = mesh.material[lastMaterialIndex];\n        // Need to start new accessors\n        if (lastMaterialIndex !== materialIndex) {\n            // And end the previous ones.\n            if (lastMaterialIndex !== null) {\n                var vertexBufferAccessorInfo = vertexBufferView.endAccessor();\n                var vertexNormalBufferAccessorInfo = vertexNormalBufferView.endAccessor();\n                var vertexUVBufferAccessorInfo = vertexUVBufferView.endAccessor();\n                var primitive = {\n                    attributes: {\n                        POSITION: addAccessor(gltf, vertexBufferIndex, vertexBufferAccessorInfo),\n                        NORMAL: addAccessor(gltf, vertexNormalBufferIndex, vertexNormalBufferAccessorInfo),\n                        TEXCOORD_0: addAccessor(gltf, vertexUVBufferIndex, vertexUVBufferAccessorInfo),\n                    },\n                    material: lastMaterialIndex,\n                    mode: mesh.mode,\n                };\n                // Only add color data if it is per-face/vertex.\n                if (lastMaterial.vertexColorMode !== _types__WEBPACK_IMPORTED_MODULE_9__[\"VertexColorMode\"].NoColors) {\n                    var vertexColorBufferAccessorInfo = vertexColorBufferView.endAccessor();\n                    primitive.attributes[\"COLOR_0\"] =\n                        addAccessor(gltf, vertexColorBufferIndex, vertexColorBufferAccessorInfo);\n                }\n                gltfMesh.primitives.push(primitive);\n            }\n            vertexBufferView.startAccessor();\n            vertexNormalBufferView.startAccessor();\n            vertexUVBufferView.startAccessor();\n            if (currentMaterial.vertexColorMode !== _types__WEBPACK_IMPORTED_MODULE_9__[\"VertexColorMode\"].NoColors)\n                vertexColorBufferView.startAccessor();\n            lastMaterialIndex = materialIndex;\n            lastMaterial = mesh.material[lastMaterialIndex];\n        }\n        // Positions\n        vertexBufferView.push(v1.x);\n        vertexBufferView.push(v1.y);\n        vertexBufferView.push(v1.z);\n        vertexBufferView.push(v2.x);\n        vertexBufferView.push(v2.y);\n        vertexBufferView.push(v2.z);\n        vertexBufferView.push(v3.x);\n        vertexBufferView.push(v3.y);\n        vertexBufferView.push(v3.z);\n        // Vertex normals\n        vertexNormalBufferView.push(v1.normalX);\n        vertexNormalBufferView.push(v1.normalY);\n        vertexNormalBufferView.push(v1.normalZ);\n        vertexNormalBufferView.push(v2.normalX);\n        vertexNormalBufferView.push(v2.normalY);\n        vertexNormalBufferView.push(v2.normalZ);\n        vertexNormalBufferView.push(v3.normalX);\n        vertexNormalBufferView.push(v3.normalY);\n        vertexNormalBufferView.push(v3.normalZ);\n        // Texture UV coords\n        vertexUVBufferView.push(v1.u);\n        vertexUVBufferView.push(v1.v);\n        vertexUVBufferView.push(v2.u);\n        vertexUVBufferView.push(v2.v);\n        vertexUVBufferView.push(v3.u);\n        vertexUVBufferView.push(v3.v);\n        // Vertex colors\n        switch (currentMaterial.vertexColorMode) {\n            case _types__WEBPACK_IMPORTED_MODULE_9__[\"VertexColorMode\"].FaceColors:\n                // Just duplicate the face colors 3 times.\n                for (var v = 0; v < 3; v++) {\n                    addColorToBufferView(vertexColorBufferView, color || new _types__WEBPACK_IMPORTED_MODULE_9__[\"RGBColor\"]());\n                }\n                break;\n            case _types__WEBPACK_IMPORTED_MODULE_9__[\"VertexColorMode\"].VertexColors:\n                addColorToBufferView(vertexColorBufferView, v1.color || new _types__WEBPACK_IMPORTED_MODULE_9__[\"RGBColor\"]());\n                addColorToBufferView(vertexColorBufferView, v2.color || new _types__WEBPACK_IMPORTED_MODULE_9__[\"RGBColor\"]());\n                addColorToBufferView(vertexColorBufferView, v3.color || new _types__WEBPACK_IMPORTED_MODULE_9__[\"RGBColor\"]());\n                break;\n            // NoColors? We won't have an accessor.\n        }\n    });\n    if (lastMaterialIndex !== null) {\n        var vertexBufferAccessorInfo = vertexBufferView.endAccessor();\n        var vertexNormalBufferAccessorInfo = vertexNormalBufferView.endAccessor();\n        var vertexUVBufferAccessorInfo = vertexUVBufferView.endAccessor();\n        var primitive = {\n            attributes: {\n                POSITION: addAccessor(gltf, vertexBufferIndex, vertexBufferAccessorInfo),\n                NORMAL: addAccessor(gltf, vertexNormalBufferIndex, vertexNormalBufferAccessorInfo),\n                TEXCOORD_0: addAccessor(gltf, vertexUVBufferIndex, vertexUVBufferAccessorInfo),\n            },\n            material: lastMaterialIndex,\n            mode: mesh.mode,\n        };\n        // Only add color data if it is per-face/vertex.\n        if (lastMaterial.vertexColorMode !== _types__WEBPACK_IMPORTED_MODULE_9__[\"VertexColorMode\"].NoColors) {\n            var vertexColorBufferAccessorInfo = vertexColorBufferView.endAccessor();\n            primitive.attributes[\"COLOR_0\"] =\n                addAccessor(gltf, vertexColorBufferIndex, vertexColorBufferAccessorInfo);\n        }\n        gltfMesh.primitives.push(primitive);\n    }\n    finalizeBuffer(gltf, meshBufferIndex);\n    finalizeBufferView(gltf, vertexBufferIndex);\n    finalizeBufferView(gltf, vertexNormalBufferIndex);\n    finalizeBufferView(gltf, vertexUVBufferIndex);\n    finalizeBufferView(gltf, vertexColorBufferIndex);\n    return addedIndex;\n}\nfunction addColorToBufferView(bufferView, color) {\n    bufferView.push((color.r * 255) | 0);\n    bufferView.push((color.g * 255) | 0);\n    bufferView.push((color.b * 255) | 0);\n    // if (color instanceof RGBAColor) {\n    //   bufferView.push((color.a * 255) | 0);\n    // }\n    // else {\n    //   bufferView.push(0xFF);\n    // }\n}\nfunction addBuffer(gltf, buffer) {\n    if (!gltf.buffers)\n        gltf.buffers = [];\n    var addedIndex = gltf.buffers.length;\n    gltf.buffers.push({\n        byteLength: -1,\n        extras: buffer,\n    });\n    return addedIndex;\n}\nfunction finalizeBuffer(gltf, bufferIndex) {\n    var gltfBuffer = gltf.buffers[bufferIndex];\n    var buffer = gltfBuffer.extras;\n    var arrayBuffer = buffer.getArrayBuffer();\n    gltfBuffer.byteLength = arrayBuffer.byteLength;\n    gltfBuffer.uri = arrayBuffer; // Still not totally finalized, see stringify\n    delete gltfBuffer.extras;\n}\nfunction addBufferView(gltf, bufferView, bufferIndex) {\n    if (!gltf.bufferViews)\n        gltf.bufferViews = [];\n    var addedIndex = gltf.bufferViews.length;\n    gltf.bufferViews.push({\n        buffer: bufferIndex,\n        byteLength: -1,\n        extras: bufferView,\n    });\n    return addedIndex;\n}\nfunction finalizeBufferView(gltf, bufferViewIndex) {\n    var gltfBufferView = gltf.bufferViews[bufferViewIndex];\n    var bufferView = gltfBufferView.extras;\n    gltfBufferView.byteOffset = bufferView.getByteOffset();\n    gltfBufferView.byteLength = bufferView.getSize();\n    delete gltfBufferView.extras;\n}\nfunction addAccessor(gltf, bufferViewIndex, accessorInfo) {\n    if (!gltf.accessors)\n        gltf.accessors = [];\n    var addedIndex = gltf.accessors.length;\n    gltf.accessors.push({\n        bufferView: bufferViewIndex,\n        byteOffset: accessorInfo.byteOffset,\n        componentType: accessorInfo.componentType,\n        count: accessorInfo.count,\n        type: accessorInfo.type,\n    });\n    return addedIndex;\n}\nfunction addMaterials(gltf, materials) {\n    var indices = [];\n    for (var _i = 0, materials_1 = materials; _i < materials_1.length; _i++) {\n        var material = materials_1[_i];\n        indices.push(addMaterial(gltf, material));\n    }\n    return indices;\n}\nfunction addMaterial(gltf, material) {\n    if (!gltf.materials)\n        gltf.materials = [];\n    var gltfMaterial = {};\n    if (material.name)\n        gltfMaterial.name = material.name;\n    if (material.alphaMode !== _types__WEBPACK_IMPORTED_MODULE_9__[\"AlphaMode\"].OPAQUE)\n        gltfMaterial.alphaMode = material.alphaMode;\n    if (material.alphaCutoff !== 0.5)\n        gltfMaterial.alphaCutoff = material.alphaCutoff;\n    if (material.doubleSided)\n        gltfMaterial.doubleSided = true;\n    if (material.pbrMetallicRoughness) {\n        if (material.pbrMetallicRoughness.baseColorFactor) {\n            ensure(gltfMaterial, \"pbrMetallicRoughness\", {});\n            gltfMaterial.pbrMetallicRoughness.baseColorFactor = material.pbrMetallicRoughness.baseColorFactor;\n        }\n        if (material.pbrMetallicRoughness.baseColorTexture) {\n            ensure(gltfMaterial, \"pbrMetallicRoughness\", {});\n            var textureIndex = addTexture(gltf, material.pbrMetallicRoughness.baseColorTexture);\n            gltfMaterial.pbrMetallicRoughness.baseColorTexture = { index: textureIndex };\n        }\n    }\n    var addedIndex = gltf.materials.length;\n    gltf.materials.push(gltfMaterial);\n    return addedIndex;\n}\nfunction ensure(obj, prop, defaultValue) {\n    obj[prop] = obj[prop] || defaultValue;\n}\nfunction addTexture(gltf, texture) {\n    if (!gltf.textures)\n        gltf.textures = [];\n    var gltfTexture = {\n        sampler: addSampler(gltf, texture),\n        source: addImage(gltf, texture.image),\n    };\n    var addedIndex = gltf.textures.length;\n    gltf.textures.push(gltfTexture);\n    return addedIndex;\n}\nfunction addImage(gltf, image) {\n    if (!gltf.images)\n        gltf.images = [];\n    var gltfImage = {};\n    gltfImage.uri = image; // Processed later\n    for (var i = 0; i < gltf.images.length; i++) {\n        if (image === gltf.images[i].uri) {\n            return i; // Already had an identical image.\n        }\n    }\n    var addedIndex = gltf.images.length;\n    gltf.images.push(gltfImage);\n    return addedIndex;\n}\nfunction addSampler(gltf, texture) {\n    if (!gltf.samplers)\n        gltf.samplers = [];\n    var gltfSampler = {\n        wrapS: texture.wrapS,\n        wrapT: texture.wrapT,\n    };\n    for (var i = 0; i < gltf.samplers.length; i++) {\n        if (objectsEqual(gltfSampler, gltf.samplers[i])) {\n            return i; // Already had an identical sampler.\n        }\n    }\n    var addedIndex = gltf.samplers.length;\n    gltf.samplers.push(gltfSampler);\n    return addedIndex;\n}\nfunction imageToDataURI(image) {\n    var canvas;\n    if (image instanceof HTMLImageElement) {\n        canvas = document.createElement(\"canvas\");\n        canvas.width = image.width;\n        canvas.height = image.height;\n        var context = canvas.getContext(\"2d\");\n        context.drawImage(image, 0, 0, image.width, image.height);\n    }\n    else {\n        canvas = image;\n    }\n    return canvas.toDataURL();\n}\nfunction encodeBase64DataUri(buf) {\n    var codes = [];\n    var uint8arr = new Uint8Array(buf);\n    for (var i = 0; i < uint8arr.length; i++) {\n        codes.push(String.fromCharCode(uint8arr[i]));\n    }\n    var b64 = btoa(codes.join(\"\"));\n    var uri = \"data:application/octet-stream;base64,\" + b64;\n    return uri;\n}\nfunction objectsEqual(obj1, obj2) {\n    return JSON.stringify(obj1) === JSON.stringify(obj2);\n}\n\n\n//# sourceURL=webpack://GLTFUtils/./src/index.ts?");

/***/ }),

/***/ "./src/material.ts":
/*!*************************!*\
  !*** ./src/material.ts ***!
  \*************************/
/*! exports provided: Material */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Material\", function() { return Material; });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"./src/types.ts\");\n\nvar Material = /** @class */ (function () {\n    function Material() {\n        this.name = \"\";\n        this.alphaCutoff = 0.5;\n        this.alphaMode = _types__WEBPACK_IMPORTED_MODULE_0__[\"AlphaMode\"].OPAQUE;\n        this.doubleSided = false;\n        this.vertexColorMode = _types__WEBPACK_IMPORTED_MODULE_0__[\"VertexColorMode\"].NoColors;\n        this.pbrMetallicRoughness = {\n            metallicFactor: 1.0,\n            roughnessFactor: 1.0,\n        };\n    }\n    return Material;\n}());\n\n\n\n//# sourceURL=webpack://GLTFUtils/./src/material.ts?");

/***/ }),

/***/ "./src/math.ts":
/*!*********************!*\
  !*** ./src/math.ts ***!
  \*********************/
/*! exports provided: XYZPair, Quaternion, toQuaternion, degreesToRadians */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"XYZPair\", function() { return XYZPair; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Quaternion\", function() { return Quaternion; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toQuaternion\", function() { return toQuaternion; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"degreesToRadians\", function() { return degreesToRadians; });\nvar XYZPair = /** @class */ (function () {\n    function XYZPair(x, y, z) {\n        this.x = 0;\n        this.y = 0;\n        this.z = 0;\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    XYZPair.prototype.toArray = function () {\n        return [this.x, this.y, this.z];\n    };\n    return XYZPair;\n}());\n\nvar Quaternion = /** @class */ (function () {\n    function Quaternion(x, y, z, w) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.w = w;\n    }\n    Quaternion.prototype.toArray = function () {\n        return [this.x, this.y, this.z, this.w];\n    };\n    return Quaternion;\n}());\n\nfunction toQuaternion(x, y, z) {\n    var cy = Math.cos(z * 0.5);\n    var sy = Math.sin(z * 0.5);\n    var cr = Math.cos(x * 0.5);\n    var sr = Math.sin(x * 0.5);\n    var cp = Math.cos(y * 0.5);\n    var sp = Math.sin(y * 0.5);\n    return new Quaternion(cy * sr * cp - sy * cr * sp, cy * cr * sp + sy * sr * cp, sy * cr * cp - cy * sr * sp, cy * cr * cp + sy * sr * sp);\n}\nfunction degreesToRadians(degrees) {\n    return degrees * Math.PI / 180;\n}\n\n\n//# sourceURL=webpack://GLTFUtils/./src/math.ts?");

/***/ }),

/***/ "./src/mesh.ts":
/*!*********************!*\
  !*** ./src/mesh.ts ***!
  \*********************/
/*! exports provided: Mesh */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Mesh\", function() { return Mesh; });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"./src/types.ts\");\n\nvar Mesh = /** @class */ (function () {\n    function Mesh() {\n        this.material = [];\n        this.mode = _types__WEBPACK_IMPORTED_MODULE_0__[\"MeshMode\"].TRIANGLES;\n        this._vertices = [];\n        this._faceColors = [];\n        this._materialIndices = [];\n    }\n    Mesh.prototype.addFace = function (v1, v2, v3, color, materialIndex) {\n        this._vertices.push(v1);\n        this._vertices.push(v2);\n        this._vertices.push(v3);\n        this._faceColors.push(color);\n        this._materialIndices.push(materialIndex);\n    };\n    Mesh.prototype.forEachFace = function (fn) {\n        for (var i = 0; i < this._vertices.length / 3; i++) {\n            fn(this._vertices[(i * 3)], this._vertices[(i * 3) + 1], this._vertices[(i * 3) + 2], this._faceColors[i], this._materialIndices[i]);\n        }\n    };\n    return Mesh;\n}());\n\n\n\n//# sourceURL=webpack://GLTFUtils/./src/mesh.ts?");

/***/ }),

/***/ "./src/node.ts":
/*!*********************!*\
  !*** ./src/node.ts ***!
  \*********************/
/*! exports provided: Node */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Node\", function() { return Node; });\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math */ \"./src/math.ts\");\n\nvar Node = /** @class */ (function () {\n    function Node() {\n        this.name = \"\";\n        this._nodes = [];\n    }\n    Node.prototype.addNode = function (node) {\n        if (this._nodes.indexOf(node) >= 0)\n            throw new Error(\"Node passed to addNode was added prior.\");\n        this._nodes.push(node);\n    };\n    Node.prototype.forEachNode = function (fn) {\n        this._nodes.forEach(fn);\n    };\n    Node.prototype.setTranslation = function (x, y, z) {\n        this._translation = new _math__WEBPACK_IMPORTED_MODULE_0__[\"XYZPair\"](x, y, z);\n    };\n    Node.prototype.getTranslation = function () {\n        return this._translation || new _math__WEBPACK_IMPORTED_MODULE_0__[\"XYZPair\"](0, 0, 0);\n    };\n    Node.prototype.setRotationDegrees = function (x, y, z) {\n        this.setRotationRadians(Object(_math__WEBPACK_IMPORTED_MODULE_0__[\"degreesToRadians\"])(x), Object(_math__WEBPACK_IMPORTED_MODULE_0__[\"degreesToRadians\"])(y), Object(_math__WEBPACK_IMPORTED_MODULE_0__[\"degreesToRadians\"])(z));\n    };\n    Node.prototype.setRotationRadians = function (x, y, z) {\n        this._rotation = Object(_math__WEBPACK_IMPORTED_MODULE_0__[\"toQuaternion\"])(x, y, z);\n    };\n    Node.prototype.setRotationQuaternion = function (x, y, z, w) {\n        this._rotation = new _math__WEBPACK_IMPORTED_MODULE_0__[\"Quaternion\"](x, y, z, w);\n    };\n    Node.prototype.getRotationQuaternion = function () {\n        return this._rotation || new _math__WEBPACK_IMPORTED_MODULE_0__[\"Quaternion\"](0, 0, 0, 1);\n    };\n    Node.prototype.setScale = function (x, y, z) {\n        this._scale = new _math__WEBPACK_IMPORTED_MODULE_0__[\"XYZPair\"](x, y, z);\n    };\n    Node.prototype.getScale = function () {\n        return this._scale || new _math__WEBPACK_IMPORTED_MODULE_0__[\"XYZPair\"](1, 1, 1);\n    };\n    return Node;\n}());\n\n\n\n//# sourceURL=webpack://GLTFUtils/./src/node.ts?");

/***/ }),

/***/ "./src/scene.ts":
/*!**********************!*\
  !*** ./src/scene.ts ***!
  \**********************/
/*! exports provided: Scene */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Scene\", function() { return Scene; });\nvar Scene = /** @class */ (function () {\n    function Scene() {\n        this.name = \"\";\n        this._nodes = [];\n    }\n    Scene.prototype.addNode = function (node) {\n        if (this._nodes.indexOf(node) >= 0)\n            throw new Error(\"Node passed to addNode was added prior.\");\n        this._nodes.push(node);\n    };\n    Scene.prototype.forEachNode = function (fn) {\n        this._nodes.forEach(fn);\n    };\n    return Scene;\n}());\n\n\n\n//# sourceURL=webpack://GLTFUtils/./src/scene.ts?");

/***/ }),

/***/ "./src/texture.ts":
/*!************************!*\
  !*** ./src/texture.ts ***!
  \************************/
/*! exports provided: Texture */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Texture\", function() { return Texture; });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"./src/types.ts\");\n\nvar Texture = /** @class */ (function () {\n    function Texture() {\n        this.wrapS = _types__WEBPACK_IMPORTED_MODULE_0__[\"WrappingMode\"].CLAMP_TO_EDGE;\n        this.wrapT = _types__WEBPACK_IMPORTED_MODULE_0__[\"WrappingMode\"].CLAMP_TO_EDGE;\n    }\n    return Texture;\n}());\n\n\n\n//# sourceURL=webpack://GLTFUtils/./src/texture.ts?");

/***/ }),

/***/ "./src/threejs.ts":
/*!************************!*\
  !*** ./src/threejs.ts ***!
  \************************/
/*! exports provided: glTFAssetFromTHREE */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"glTFAssetFromTHREE\", function() { return glTFAssetFromTHREE; });\n/* harmony import */ var _asset__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./asset */ \"./src/asset.ts\");\n/* harmony import */ var _scene__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scene */ \"./src/scene.ts\");\n/* harmony import */ var _node__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node */ \"./src/node.ts\");\n/* harmony import */ var _mesh__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mesh */ \"./src/mesh.ts\");\n/* harmony import */ var _material__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./material */ \"./src/material.ts\");\n/* harmony import */ var _texture__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./texture */ \"./src/texture.ts\");\n/* harmony import */ var _vertex__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./vertex */ \"./src/vertex.ts\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./types */ \"./src/types.ts\");\n\n\n\n\n\n\n\n\nfunction glTFAssetFromTHREE(obj) {\n    var asset = new _asset__WEBPACK_IMPORTED_MODULE_0__[\"GLTFAsset\"]();\n    var scene = new _scene__WEBPACK_IMPORTED_MODULE_1__[\"Scene\"]();\n    scene.name = obj.name;\n    asset.addScene(scene);\n    scene.addNode(NodeFromTHREE(obj));\n    return asset;\n}\nfunction NodeFromTHREE(obj) {\n    var node = new _node__WEBPACK_IMPORTED_MODULE_2__[\"Node\"]();\n    node.name = obj.name;\n    if (isTHREEMesh(obj)) {\n        node.mesh = MeshFromTHREE(obj);\n    }\n    else {\n        node.setTranslation(obj.position.x, obj.position.y, obj.position.z);\n        node.setRotationRadians(obj.rotation.x, obj.rotation.y, obj.rotation.z);\n        node.setScale(obj.scale.x, obj.scale.y, obj.scale.z);\n        for (var _i = 0, _a = obj.children; _i < _a.length; _i++) {\n            var child = _a[_i];\n            node.addNode(NodeFromTHREE(child));\n        }\n    }\n    return node;\n}\nfunction MeshFromTHREE(obj) {\n    var mesh = new _mesh__WEBPACK_IMPORTED_MODULE_3__[\"Mesh\"]();\n    var threeGeometry = obj.geometry;\n    if (isTHREEGeometry(threeGeometry)) {\n        for (var i = 0; i < threeGeometry.faces.length; i++) {\n            var face = threeGeometry.faces[i];\n            var faceColor = new _types__WEBPACK_IMPORTED_MODULE_7__[\"RGBColor\"]();\n            faceColor.r = face.color.r;\n            faceColor.g = face.color.g;\n            faceColor.b = face.color.b;\n            mesh.addFace(VertexFromTHREE(threeGeometry, i, face.a, 0), VertexFromTHREE(threeGeometry, i, face.b, 1), VertexFromTHREE(threeGeometry, i, face.c, 2), faceColor, face.materialIndex);\n        }\n        mesh.material = MaterialsFromTHREE(obj.material);\n    }\n    else {\n        throw new Error(\"BufferGeometry (or other type) not supported.\");\n    }\n    return mesh;\n}\nfunction MaterialsFromTHREE(threeMaterial) {\n    var materials = [];\n    if (!Array.isArray(threeMaterial)) {\n        threeMaterial = [threeMaterial];\n    }\n    for (var _i = 0, threeMaterial_1 = threeMaterial; _i < threeMaterial_1.length; _i++) {\n        var mat = threeMaterial_1[_i];\n        materials.push(MaterialFromTHREE(mat));\n    }\n    return materials;\n}\nfunction MaterialFromTHREE(threeMaterial) {\n    var material = new _material__WEBPACK_IMPORTED_MODULE_4__[\"Material\"]();\n    material.doubleSided = threeMaterial.side === 2; // THREE.DoubleSide;\n    if (isTHREEMeshBasicMaterial(threeMaterial)) {\n        material.pbrMetallicRoughness.metallicFactor = 0;\n        material.pbrMetallicRoughness.roughnessFactor = 0;\n        if (threeMaterial.transparent) {\n            material.alphaMode = _types__WEBPACK_IMPORTED_MODULE_7__[\"AlphaMode\"].MASK;\n            material.alphaCutoff = threeMaterial.alphaTest;\n        }\n        material.vertexColorMode = threeMaterial.vertexColors;\n        if (threeMaterial.color && threeMaterial.vertexColors === 0 /* THREE.NoColors */) {\n            material.pbrMetallicRoughness.baseColorFactor = [\n                threeMaterial.color.r,\n                threeMaterial.color.g,\n                threeMaterial.color.b,\n                1\n            ];\n        }\n        if (threeMaterial.map) {\n            var texture = new _texture__WEBPACK_IMPORTED_MODULE_5__[\"Texture\"]();\n            texture.image = threeMaterial.map.image;\n            texture.wrapS = WrappingModeFromTHREE(threeMaterial.map.wrapS);\n            texture.wrapT = WrappingModeFromTHREE(threeMaterial.map.wrapT);\n            material.pbrMetallicRoughness.baseColorTexture = texture;\n        }\n    }\n    else {\n        throw new Error(threeMaterial.type + \" is currently not supported.\");\n    }\n    return material;\n}\nfunction VertexFromTHREE(threeGeometry, faceIndex, vertexIndex, vertexRelIndex) {\n    var vertex = new _vertex__WEBPACK_IMPORTED_MODULE_6__[\"Vertex\"]();\n    var threeVertex = threeGeometry.vertices[vertexIndex];\n    vertex.x = threeVertex.x;\n    vertex.y = threeVertex.y;\n    vertex.z = threeVertex.z;\n    if (threeGeometry.faceVertexUvs[0] && threeGeometry.faceVertexUvs[0][faceIndex]\n        && threeGeometry.faceVertexUvs[0][faceIndex][vertexRelIndex]) {\n        vertex.u = threeGeometry.faceVertexUvs[0][faceIndex][vertexRelIndex].x;\n        vertex.v = threeGeometry.faceVertexUvs[0][faceIndex][vertexRelIndex].y;\n    }\n    var threeFace = threeGeometry.faces[faceIndex];\n    if (threeFace.vertexNormals[vertexRelIndex]) {\n        vertex.normalX = threeFace.vertexNormals[vertexRelIndex].x;\n        vertex.normalY = threeFace.vertexNormals[vertexRelIndex].y;\n        vertex.normalZ = threeFace.vertexNormals[vertexRelIndex].z;\n    }\n    if (threeFace.vertexColors[vertexRelIndex]) {\n        vertex.color = new _types__WEBPACK_IMPORTED_MODULE_7__[\"RGBColor\"]();\n        vertex.color.r = threeFace.vertexColors[vertexRelIndex].r;\n        vertex.color.g = threeFace.vertexColors[vertexRelIndex].g;\n        vertex.color.b = threeFace.vertexColors[vertexRelIndex].b;\n    }\n    return vertex;\n}\nfunction WrappingModeFromTHREE(mode) {\n    switch (mode) {\n        case 1000: // THREE.RepeatWrapping\n            return _types__WEBPACK_IMPORTED_MODULE_7__[\"WrappingMode\"].REPEAT;\n        case 1002: // THREE.MirroredRepeatWrapping\n            return _types__WEBPACK_IMPORTED_MODULE_7__[\"WrappingMode\"].MIRRORED_REPEAT;\n        case 1001: // THREE.ClampToEdgeWrapping\n        default:\n            return _types__WEBPACK_IMPORTED_MODULE_7__[\"WrappingMode\"].CLAMP_TO_EDGE;\n    }\n}\nfunction isTHREEMesh(obj) {\n    return obj.type === \"Mesh\";\n}\nfunction isTHREEGeometry(obj) {\n    return obj.type === \"Geometry\";\n}\nfunction isTHREEMeshBasicMaterial(obj) {\n    return obj.type === \"MeshBasicMaterial\";\n}\n\n\n//# sourceURL=webpack://GLTFUtils/./src/threejs.ts?");

/***/ }),

/***/ "./src/types.ts":
/*!**********************!*\
  !*** ./src/types.ts ***!
  \**********************/
/*! exports provided: ComponentType, DataType, MeshMode, WrappingMode, AlphaMode, RGBColor, RGBAColor, VertexColorMode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ComponentType\", function() { return ComponentType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DataType\", function() { return DataType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MeshMode\", function() { return MeshMode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WrappingMode\", function() { return WrappingMode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AlphaMode\", function() { return AlphaMode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBColor\", function() { return RGBColor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RGBAColor\", function() { return RGBAColor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VertexColorMode\", function() { return VertexColorMode; });\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    }\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar ComponentType;\n(function (ComponentType) {\n    ComponentType[ComponentType[\"BYTE\"] = 5120] = \"BYTE\";\n    ComponentType[ComponentType[\"UNSIGNED_BYTE\"] = 5121] = \"UNSIGNED_BYTE\";\n    ComponentType[ComponentType[\"SHORT\"] = 5122] = \"SHORT\";\n    ComponentType[ComponentType[\"UNSIGNED_SHORT\"] = 5123] = \"UNSIGNED_SHORT\";\n    ComponentType[ComponentType[\"UNSIGNED_INT\"] = 5125] = \"UNSIGNED_INT\";\n    ComponentType[ComponentType[\"FLOAT\"] = 5126] = \"FLOAT\";\n})(ComponentType || (ComponentType = {}));\nvar DataType;\n(function (DataType) {\n    DataType[\"SCALAR\"] = \"SCALAR\";\n    DataType[\"VEC2\"] = \"VEC2\";\n    DataType[\"VEC3\"] = \"VEC3\";\n    DataType[\"VEC4\"] = \"VEC4\";\n    DataType[\"MAT2\"] = \"MAT2\";\n    DataType[\"MAT3\"] = \"MAT3\";\n    DataType[\"MAT4\"] = \"MAT4\";\n})(DataType || (DataType = {}));\nvar MeshMode;\n(function (MeshMode) {\n    MeshMode[MeshMode[\"POINTS\"] = 0] = \"POINTS\";\n    MeshMode[MeshMode[\"LINES\"] = 1] = \"LINES\";\n    MeshMode[MeshMode[\"LINE_LOOP\"] = 2] = \"LINE_LOOP\";\n    MeshMode[MeshMode[\"LINE_STRIP\"] = 3] = \"LINE_STRIP\";\n    MeshMode[MeshMode[\"TRIANGLES\"] = 4] = \"TRIANGLES\";\n    MeshMode[MeshMode[\"TRIANGLE_STRIP\"] = 5] = \"TRIANGLE_STRIP\";\n    MeshMode[MeshMode[\"TRIANGLE_FAN\"] = 6] = \"TRIANGLE_FAN\";\n})(MeshMode || (MeshMode = {}));\nvar WrappingMode;\n(function (WrappingMode) {\n    WrappingMode[WrappingMode[\"CLAMP_TO_EDGE\"] = 33071] = \"CLAMP_TO_EDGE\";\n    WrappingMode[WrappingMode[\"MIRRORED_REPEAT\"] = 33648] = \"MIRRORED_REPEAT\";\n    WrappingMode[WrappingMode[\"REPEAT\"] = 10497] = \"REPEAT\";\n})(WrappingMode || (WrappingMode = {}));\nvar AlphaMode;\n(function (AlphaMode) {\n    AlphaMode[\"OPAQUE\"] = \"OPAQUE\";\n    AlphaMode[\"MASK\"] = \"MASK\";\n    AlphaMode[\"BLEND\"] = \"BLEND\";\n})(AlphaMode || (AlphaMode = {}));\nvar RGBColor = /** @class */ (function () {\n    function RGBColor() {\n        /** Red, between 0 and 1. */\n        this.r = 1;\n        /** Green, between 0 and 1 */\n        this.g = 1;\n        /** Blue, between 0 and 1 */\n        this.b = 1;\n    }\n    return RGBColor;\n}());\n\nvar RGBAColor = /** @class */ (function (_super) {\n    __extends(RGBAColor, _super);\n    function RGBAColor() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        /** Alpha, between 0 and 1 */\n        _this.a = 1;\n        return _this;\n    }\n    return RGBAColor;\n}(RGBColor));\n\n// Matches THREE Colors\nvar VertexColorMode;\n(function (VertexColorMode) {\n    VertexColorMode[VertexColorMode[\"NoColors\"] = 0] = \"NoColors\";\n    VertexColorMode[VertexColorMode[\"FaceColors\"] = 1] = \"FaceColors\";\n    VertexColorMode[VertexColorMode[\"VertexColors\"] = 2] = \"VertexColors\";\n})(VertexColorMode || (VertexColorMode = {}));\n\n\n//# sourceURL=webpack://GLTFUtils/./src/types.ts?");

/***/ }),

/***/ "./src/vertex.ts":
/*!***********************!*\
  !*** ./src/vertex.ts ***!
  \***********************/
/*! exports provided: Vertex */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Vertex\", function() { return Vertex; });\nvar Vertex = /** @class */ (function () {\n    function Vertex() {\n        this.x = 0;\n        this.y = 0;\n        this.z = 0;\n        this.u = 0;\n        this.v = 0;\n        this.normalX = 0;\n        this.normalY = 0;\n        this.normalZ = 0;\n    }\n    return Vertex;\n}());\n\n\n\n//# sourceURL=webpack://GLTFUtils/./src/vertex.ts?");

/***/ })

/******/ });
});